//
//  ECMutableFileRenderer.m
//  CodeView3
//
//  Created by Nicola Peduzzi on 12/04/11.
//  Copyright 2011 __MyCompanyName__. All rights reserved.
//

#import "ECMutableTextFileRenderer.h"
#import <CoreText/CoreText.h>

@class FramesetterInfo;
@class FrameInfo;

#pragma mark -
#pragma mark FrameInfo

@protocol FrameInfoDelegate <NSObject>
@required
/// Called when the FrameInfo need to generate it's frame. The implmenter
/// should call generateWithFramesetter:stringRange:boundRect:.
- (void)frameInfoRequireGeneration:(FrameInfo *)frameInfo;
@end

@interface FrameInfo : NSObject

@property (assign) id<FrameInfoDelegate> delegate;

/// Hold a reference to the frame connected with this info block.
/// This reference may be NULL is the frame has been released due to no use.
@property (readonly) CTFrameRef frame;

/// Rect used to render the frame. This rect should have his width equal
/// to the frameWidth property.
@property (readonly) CGRect generationRect;

/// The string range used to render the frame.
@property (readonly) CFRange generationStringRange;

/// The effective string range rendered int the frame.
@property (readonly) CFRange actualStringRange;

/// Contains the actual size of this frame. Width may be smaler than rect's
/// one and height is calculated from the top of the first line to the 
/// bottom of the last rendered one.
@property (readonly) CGSize actualSize;

- (id)initWithDelegate:(id<FrameInfoDelegate>)del;

/// Release the frame but keeps cached rendering informations available.
- (void)releaseFrame;

- (void)generateWithFramesetter:(CTFramesetterRef)framesetter stringRange:(CFRange)range boundRect:(CGRect)bounds;

- (void)enumerateAllLinesUsingBlock:(void(^)(CTLineRef line, CFIndex idx, BOOL *stop))block;

- (void)enumerateLinesIntersectingRect:(CGRect)rect usingBlock:(void(^)(CTLineRef line, BOOL *stop))block;

@end

@implementation FrameInfo

@synthesize delegate, frame, generationRect, generationStringRange, actualStringRange, actualSize;

- (id)initWithDelegate:(id<FrameInfoDelegate>)del
{
    if ((self = [super init])) 
    {
        delegate = del;
    }
    return self;
}

- (CTFrameRef)frame
{
    if (!delegate) 
    {
        [NSException raise:@"Invalid delegate" format:@"Delegate should be set to a valid instance and implement FrameInfoDelegate."];
    }
    // TODO probably better not a while loop?
    while (!frame)
    {
        [delegate frameInfoRequireGeneration:self];
    }
    return frame;
}

- (void)dealloc
{
    [self releaseFrame];
    [super dealloc];
}

- (void)releaseFrame
{
    if (frame) 
    {
        CFRelease(frame);
        frame = NULL;
    }
}

- (void)generateWithFramesetter:(CTFramesetterRef)framesetter stringRange:(CFRange)range boundRect:(CGRect)bounds
{
    [self releaseFrame];
    CGMutablePathRef path = CGPathCreateMutable();
    CGPathAddRect(path, NULL, bounds);
    
    frame = CTFramesetterCreateFrame(framesetter, range, path, NULL);
    generationRect = bounds;
    generationStringRange = range;
    actualStringRange = CTFrameGetVisibleStringRange(frame);
    
    __block CGSize accumSize = CGSizeZero;
    __block CGFloat width, ascent, descent;
    [self enumerateAllLinesUsingBlock:^(CTLineRef line, CFIndex idx, BOOL *stop) {
        width = CTLineGetTypographicBounds(line, &ascent, &descent, NULL);
        accumSize.width = MAX(accumSize.width, width);
        accumSize.height += ascent + descent;
    }];
    actualSize = accumSize;
    
    CGPathRelease(path);
}

- (void)enumerateAllLinesUsingBlock:(void (^)(CTLineRef, CFIndex, BOOL *))block
{
    BOOL stop = NO;
    CFArrayRef lines = CTFrameGetLines(self.frame);
    CFIndex lineCount = CFArrayGetCount(lines);
    for (CFIndex i = 0; i < lineCount; ++i) 
    {
        CTLineRef line = CFArrayGetValueAtIndex(lines, i);
        block(line, i, &stop);
        if (stop) break;
    }
}

@end

#pragma mark -
#pragma mark FramesetterInfo

@protocol FramesetterInfoDelegate <NSObject>
@required
/// Called when a FramesetterInfo require to create it's framesetter.
/// The implementer should call generateFramesetterWithString:preferredFrameSize: on the given framesetterInfo.
- (void)framesetterInfoRequireGeneration:(FramesetterInfo *)framesetterInfo;
@end

@interface FramesetterInfo : NSObject <FrameInfoDelegate> {
@private
    /// Hold a reference to the framesetter connected with this info block. 
    /// This reference may be NULL if cleaning required the framesetter to be
    /// deallocated because not used.
    CTFramesetterRef framesetter;
    
    /// The array of frames generated by this framesetter.
    NSMutableArray *frames;
    
    // TODO editing data and string attributes cache
}

/// The delegate (TODO or datasource?) for this FramesetterInfo.
@property (assign) id<FramesetterInfoDelegate> delegate;

@property CGSize framesPreferredSize;

/// The string range in the content text that this framesetter is handling.
@property (readonly) CFRange stringRange;

/// Get the actual rendered size of the union of the framesetter's generated
/// framses originated accordingly with previous framesetters.
@property (readonly) CGSize actualSize;

- (id)initWithDelegate:(id<FramesetterInfoDelegate>)del;

/// Release the framesetter but keep cached rendering informations available.
- (void)releaseFramesetter;

/// Release any previous framesetter and generate a new one from the given string.
- (void)generateFramesetterWithString:(NSAttributedString *)string preferredFrameSize:(CGSize)size;

- (void)enumerateFrameInfoIntersectingRect:(CGRect)rect usingBlock:(void(^)(FrameInfo *frameInfo, BOOL *stop))block;

@end

@implementation FramesetterInfo

@synthesize delegate, framesPreferredSize, stringRange, actualSize;

- (id)initWithDelegate:(id<FramesetterInfoDelegate>)del
{
    if ((self = [super init])) 
    {
        delegate = del;
        frames = [NSMutableArray new];
    }
    return self;
}

- (void)dealloc
{
    [self releaseFramesetter];
    [frames release];
    [super dealloc];
}

- (void)releaseFramesetter
{
    if (framesetter)
    {
        CFRelease(framesetter);
        framesetter = NULL;
    }
}

- (void)generateFramesetterWithString:(NSAttributedString *)string preferredFrameSize:(CGSize)size
{
    [self releaseFramesetter];
    framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)string);
    framesPreferredSize = size;
    
    NSUInteger stringLength = [string length];
    CFRange frameRange = stringRange = CFRangeMake(0, 0);
    CGRect frameRect = (CGRect){ CGPointZero, framesPreferredSize };
    actualSize = CGSizeZero;
    
    [frames removeAllObjects];
    FrameInfo *frameInfo;
    while (stringRange.length != stringLength) 
    {
        frameInfo = [[FrameInfo alloc] initWithDelegate:self];
        [frameInfo generateWithFramesetter:framesetter stringRange:frameRange boundRect:frameRect];
        
        frameRange.location += frameInfo.actualStringRange.length;
        stringRange.length += frameInfo.actualStringRange.length;
        
        actualSize.width = MAX(actualSize.width, frameInfo.actualSize.width);
        actualSize.height += frameInfo.actualSize.height;
        
        [frames addObject:frameInfo];
        [frameInfo release];
    }
}

- (void)frameInfoRequireGeneration:(FrameInfo *)frameInfo
{
    if (!delegate) 
    {
        [NSException raise:@"Invalid delegate" format:@"Delegate should be set to a valid instance and implement FramesetterInfoDelegate."];
    }
    // TODO probably better not a while loop?
    while (!framesetter) 
    {
        [delegate framesetterInfoRequireGeneration:self];
    }
    
    // TODO manage editing here?
    [frameInfo generateWithFramesetter:framesetter 
                           stringRange:frameInfo.generationStringRange 
                             boundRect:frameInfo.generationRect];
}

@end


#pragma mark Class continuations
@interface ECMutableTextFileRenderer () <FramesetterInfoDelegate> {
@private
    // TODO use a cache of frameWidth -> info dictionary
//    NSCache *widthCache;
    
    NSMutableArray *framesetters;
    
    NSAttributedString *string;
}

- (void)invalidateAllFramesetters;

/// Sequentially cache all rendering informations up through the given rect by
/// generating them if not already present and keeping actual rendered frames
/// for the specified rect if keep is YES.
- (void)cacheRenderingInformationsUpThroughRect:(CGRect)rect andKeepFramesIntersectingRect:(BOOL)keep;

- (void)enumerateFramesetterInfoIntersectingRect:(CGRect)rect usingBlock:(void(^)(FramesetterInfo *framesetterInfo, BOOL *stop))block;
@end

#pragma mark ECMutableTextFileRenderer Implementation
@implementation ECMutableTextFileRenderer

#pragma mark Properties
@synthesize lazyCaching;
@synthesize framesetterStringLengthLimit;
@synthesize framePreferredHeight;
@synthesize frameWidth;

- (void)setString:(NSAttributedString *)aString
{
    [string release];
    string = [aString retain];
    
    [self invalidateAllFramesetters];
}

#pragma mark -
#pragma mark Initialization

- (id)init {
    if ((self = [super init])) 
    {
        framesetterStringLengthLimit = 0;
        framePreferredHeight = 1024;
        frameWidth = 768;
    }
    return self;
}

#pragma mark -
#pragma mark Framesetters and frame generation

- (void)framesetterInfoRequireGeneration:(FramesetterInfo *)framesetterInfo
{
    [framesetterInfo generateFramesetterWithString:string preferredFrameSize:CGSizeMake(frameWidth, framePreferredHeight)];
}

- (void)invalidateAllFramesetters
{
    
}

#pragma mark -
#pragma mark Rendering and cacheing

- (void)cacheRenderingInformationsUpThroughRect:(CGRect)rect andKeepFramesIntersectingRect:(BOOL)keep
{
    CGFloat keepFromPoint = CGFLOAT_MAX;
    CGFloat cacheUpToPoint = CGFLOAT_MAX;
    // If no rect specified, generate cache for all text
    if (CGRectIsEmpty(rect) || CGRectIsNull(rect)) 
    {
        keep = NO;
    }
    else
    {
        keepFromPoint = keep ? rect.origin.y : CGFLOAT_MAX;
        cacheUpToPoint = rect.origin.y + rect.size.height;
    }
    // Check for already present cache informations
    CGFloat coveredHeight = 0;
    for (FramesetterInfo *framesetterInfo in framesetters) 
    {
        coveredHeight += framesetterInfo.actualSize.height;
    }
    // Generate missing informations
    if (coveredHeight < cacheUpToPoint) 
    {
        
    }
}

- (void)drawTextInBounds:(CGRect)bounds inContext:(CGContextRef)context
{
    [self cacheRenderingInformationsUpThroughRect:bounds andKeepFramesIntersectingRect:YES];
    
    __block CGFloat width, ascent, descent;
    [self enumerateFramesetterInfoIntersectingRect:bounds usingBlock:^(FramesetterInfo *framesetterInfo, BOOL *stop) {
        [framesetterInfo enumerateFrameInfoIntersectingRect:bounds usingBlock:^(FrameInfo *frameInfo, BOOL *stop) {
            [frameInfo enumerateLinesIntersectingRect:bounds usingBlock:^(CTLineRef line, BOOL *stop) {
                width = CTLineGetTypographicBounds(line, &ascent, &descent, NULL);
                CTLineDraw(line, context);
                // TODO use + or - depending on context flipped
                CGContextTranslateCTM(context, -width, -ascent -descent);
            }];
        }];
    }];
}
@end
